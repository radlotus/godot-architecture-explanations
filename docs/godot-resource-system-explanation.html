<h1 id="godots-resource-system-architecture">Godot’s Resource System
Architecture</h1>
<p>This document explains Godot’s Resource system, the foundation for
how all data and assets are managed in the engine. Understanding this
system is key to efficient memory management and data handling. We will
also explore how to build a robust, analogous system for web
applications.</p>
<h2 id="core-principles">Core Principles</h2>
<ol type="1">
<li><strong>Everything is a Resource:</strong> In Godot, nearly any
piece of data that can be saved to disk is a <code>Resource</code>. This
includes scenes (<code>PackedScene</code>), scripts
(<code>GDScript</code>), images (<code>Texture2D</code>), fonts, audio
files, themes, animations, and more.</li>
<li><strong>Uniqueness by Path:</strong> A resource is uniquely
identified by its file path. Loading the same path multiple times will
always return a reference to the <em>exact same object</em> in memory.
The engine does not load the same file more than once.</li>
<li><strong>Automatic Memory Management:</strong> Resources are
reference-counted. The engine keeps track of how many things are using a
resource. When nothing is using it anymore, it is automatically freed
from memory. This prevents memory leaks.</li>
<li><strong>Decoupled Loading:</strong> A global
<code>ResourceLoader</code> singleton handles the logic for loading
different file types. It uses a chain of specialized format loaders to
handle everything from PNG images to TSCN scene files.</li>
</ol>
<hr />
<h2 id="the-architectural-building-blocks">The Architectural Building
Blocks</h2>
<h3 id="the-resource-class">The <code>Resource</code> Class</h3>
<p>The <code>Resource</code> class (<code>core/io/resource.h</code>) is
the base for all assets. It inherits from <code>RefCounted</code>, which
is the key to its memory management.</p>
<ul>
<li><strong><code>RefCounted</code>:</strong> This base class contains
an internal counter. When you pass a <code>Resource</code> around, you
use a smart pointer called <code>Ref&lt;Resource&gt;</code>. When a
<code>Ref</code> is created or copied, the counter goes up. When a
<code>Ref</code> is destroyed, the counter goes down. When the counter
reaches zero, the <code>Resource</code> is automatically deleted.</li>
<li><strong>Path:</strong> A resource has a <code>path</code> property
that links it to its file on disk. This is its unique identifier.</li>
<li><strong>RID:</strong> A resource often has a <code>get_rid()</code>
method. This returns its unique ID on one of the low-level servers
(e.g., the <code>RID</code> of a texture on the
<code>RenderingServer</code>). This is the bridge between the high-level
<code>Resource</code> object and the low-level server backend.</li>
</ul>
<h3 id="the-resourceloader-singleton">The <code>ResourceLoader</code>
Singleton</h3>
<p><code>ResourceLoader</code> (<code>core/io/resource_loader.h</code>)
is a global singleton responsible for loading resources from files. It
is the engine behind the <code>load()</code> function in GDScript.</p>
<p>Here is the process when you call
<code>load("res://player.png")</code>:</p>
<ol type="1">
<li><strong>Check Cache:</strong> The <code>ResourceLoader</code> first
checks the global <code>ResourceCache</code>. If a resource with the
path <code>"res://player.png"</code> is already in memory, it
immediately returns a reference to it.</li>
<li><strong>Find a Loader:</strong> If not in the cache,
<code>ResourceLoader</code> queries its list of registered
<code>ResourceFormatLoader</code> objects. It asks each one if it can
handle the given file extension (<code>.png</code>).</li>
<li><strong>Load Data:</strong> The appropriate
<code>ResourceFormatLoader</code> (e.g.,
<code>ResourceFormatLoaderPNG</code>) is then tasked with reading the
file from disk and creating a <code>Texture2D</code> resource object
from its data.</li>
<li><strong>Store in Cache:</strong> Before returning, the newly created
resource is stored in the <code>ResourceCache</code> with its path as
the key.</li>
<li><strong>Return Reference:</strong> A
<code>Ref&lt;Texture2D&gt;</code> is returned to the caller.</li>
</ol>
<p>This caching mechanism is vital for performance and memory
efficiency.</p>
<h3 id="the-resourcesaver-singleton">The <code>ResourceSaver</code>
Singleton</h3>
<p><code>ResourceSaver</code> (<code>core/io/resource_saver.h</code>) is
the counterpart to the loader. When you call
<code>ResourceSaver.save(resource, "res://path/to/file")</code>, it
finds the appropriate <code>ResourceFormatSaver</code> for the given
resource type and writes its properties to a file on disk.</p>
<hr />
<h2 id="translating-the-resource-system-to-the-web">Translating the
Resource System to the Web</h2>
<p>This is a highly practical pattern to replicate for any non-trivial
web application or game to manage assets like images, audio, and JSON
data.</p>
<h3 id="the-resourcemanager-singleton">The <code>ResourceManager</code>
Singleton</h3>
<p>You can create a singleton class to act as your
<code>ResourceLoader</code>.</p>
<ul>
<li><strong>The Cache:</strong> The manager will have an internal
<code>Map</code> object to act as the resource cache.</li>
<li><strong>Asynchronous Loading:</strong> All modern web I/O is
asynchronous. Therefore, your <code>load</code> method will return a
<code>Promise</code> that resolves with the loaded resource.</li>
<li><strong>Promise Caching:</strong> A key trick is to cache the
<code>Promise</code> itself. If you request the same resource multiple
times while it’s still loading, you return the same loading promise,
preventing multiple network requests for the same file.</li>
</ul>
<h3 id="example-implementation">Example Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ResourceManager {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>() {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The cache will store promises.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">cache</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">Map</span>()<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(url) {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 1. Check cache: If we have a promise for this url, return it.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="kw">this</span><span class="op">.</span><span class="at">cache</span><span class="op">.</span><span class="fu">has</span>(url)) {</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">cache</span><span class="op">.</span><span class="fu">get</span>(url)<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 2. Find a loader: Determine file type from extension.</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> extension <span class="op">=</span> url<span class="op">.</span><span class="fu">split</span>(<span class="st">&#39;.&#39;</span>)<span class="op">.</span><span class="fu">pop</span>()<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> loadingPromise<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ([<span class="st">&#39;png&#39;</span><span class="op">,</span> <span class="st">&#39;jpg&#39;</span><span class="op">,</span> <span class="st">&#39;gif&#39;</span>]<span class="op">.</span><span class="fu">includes</span>(extension)) {</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Loader for images</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      loadingPromise <span class="op">=</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> img <span class="op">=</span> <span class="kw">new</span> <span class="fu">Image</span>()<span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        img<span class="op">.</span><span class="at">onload</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="fu">resolve</span>(img)<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        img<span class="op">.</span><span class="at">onerror</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="fu">reject</span>(<span class="vs">`Failed to load image: </span><span class="sc">${</span>url<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        img<span class="op">.</span><span class="at">src</span> <span class="op">=</span> url<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>      })<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (extension <span class="op">===</span> <span class="st">&#39;json&#39;</span>) {</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Loader for JSON data</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>      loadingPromise <span class="op">=</span> <span class="fu">fetch</span>(url)<span class="op">.</span><span class="fu">then</span>(response <span class="kw">=&gt;</span> response<span class="op">.</span><span class="fu">json</span>())<span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> ([<span class="st">&#39;mp3&#39;</span><span class="op">,</span> <span class="st">&#39;ogg&#39;</span><span class="op">,</span> <span class="st">&#39;wav&#39;</span>]<span class="op">.</span><span class="fu">includes</span>(extension)) {</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Loader for audio (requires an AudioContext instance)</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>      loadingPromise <span class="op">=</span> <span class="fu">fetch</span>(url)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">then</span>(response <span class="kw">=&gt;</span> response<span class="op">.</span><span class="fu">arrayBuffer</span>())</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">then</span>(buffer <span class="kw">=&gt;</span> audioContext<span class="op">.</span><span class="fu">decodeAudioData</span>(buffer))<span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      <span class="co">// No loader found</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">reject</span>(<span class="vs">`No loader for file type: </span><span class="sc">${</span>extension<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 3. Store in cache: Store the promise in the cache immediately.</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">cache</span><span class="op">.</span><span class="fu">set</span>(url<span class="op">,</span> loadingPromise)<span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 4. Return reference (the promise)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loadingPromise<span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a single, global instance.</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> resourceManager <span class="op">=</span> <span class="kw">new</span> <span class="fu">ResourceManager</span>()<span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="co">// --- How to use it ---</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">main</span>() {</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> [playerImg<span class="op">,</span> levelData] <span class="op">=</span> <span class="cf">await</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">all</span>([</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>      resourceManager<span class="op">.</span><span class="fu">load</span>(<span class="st">&#39;./sprites/player.png&#39;</span>)<span class="op">,</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>      resourceManager<span class="op">.</span><span class="fu">load</span>(<span class="st">&#39;./levels/level1.json&#39;</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    ])<span class="op">;</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now you have the loaded assets</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">document</span><span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">appendChild</span>(playerImg)<span class="op">;</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(levelData<span class="op">.</span><span class="at">name</span>)<span class="op">;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (error) {</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;Failed to load resources:&quot;</span><span class="op">,</span> error)<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="fu">main</span>()<span class="op">;</span></span></code></pre></div>
<h3 id="memory-management">Memory Management</h3>
<p>JavaScript is a garbage-collected language. You do not need to
implement reference counting manually. As long as an object (like a
loaded image or JSON object) is reachable from your code, it will stay
in memory. When you are truly done with it (i.e., no variables or DOM
elements reference it anymore), the garbage collector will automatically
free it. Your <code>ResourceManager</code>’s cache will keep resources
in memory for the lifetime of the application, which is usually the
desired behavior.</p>
